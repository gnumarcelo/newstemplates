<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/Library/Ruby/Gems/1.8/gems/httpclient-2.1.4/lib/httpclient/http.rb - C0 code coverage information</title>
    <style type='text/css'>body { background-color: rgb(240, 240, 245); }</style>
    <style type='text/css'>span.cross-ref-title {
 font-size: 140%;
}
span.cross-ref a {
 text-decoration: none;
}
span.cross-ref {
 background-color:#f3f7fa;
 border: 1px dashed #333;
 margin: 1em;
 padding: 0.5em;
 overflow: hidden;
}
a.crossref-toggle {
 text-decoration: none;
}
span.marked0 {
 background-color: rgb(185, 210, 200);
 display: block;
}
span.marked1 {
 background-color: rgb(190, 215, 205);
 display: block;
}
span.inferred0 {
 background-color: rgb(255, 255, 240);
 display: block;
}
span.inferred1 {
 background-color: rgb(255, 255, 240);
 display: block;
}
span.uncovered0 {
 background-color: rgb(225, 110, 110);
 display: block;
}
span.uncovered1 {
 background-color: rgb(235, 120, 120);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
/* Commented out for better readability, esp. on IE */
/*
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
*/
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value,
table.report td.lines_total,
table.report td.lines_code {
 text-align: right;
 border: #d0d0d0 1px solid;
}
table.report tr.light {
 background-color: rgb(240, 240, 245);
}
table.report tr.dark {
 background-color: rgb(230, 230, 235);
}
</style>
    <script type='text/javascript'>
// <![CDATA[
  function toggleCode( id ) {
    if ( document.getElementById )
      elem = document.getElementById( id );
    else if ( document.all )
      elem = eval( "document.all." + id );
    else
      return false;

    elemStyle = elem.style;

    if ( elemStyle.display != "block" ) {
      elemStyle.display = "block"
    } else {
      elemStyle.display = "none"
    }

    return true;
  }

  // Make cross-references hidden by default
  document.writeln( "<style type=\"text/css\">span.cross-ref { display: none }</style>" )
  // ]]>
</script>
    <style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style>
    </head>
  <body><h3>C0 code coverage information</h3>
    <p>Generated on Fri Jun 12 17:27:55 +0100 2009 with <a href='http://github.com/spicycode/rcov'>rcov 0.8.2.1</a>
      </p>
    <hr/>
    <pre><span class='marked0'>Code reported as executed by Ruby looks like this...
</span><span class='marked1'>and this: this line is also marked as covered.
</span><span class='inferred0'>Lines considered as run by rcov, but not reported by Ruby, look like this,
</span><span class='inferred1'>and this: these lines were inferred by rcov (using simple heuristics).
</span><span class='uncovered0'>Finally, here&apos;s a line marked as not executed.
</span></pre>
<table class='report'><thead><tr><td class='heading'>Name</td>
      <td class='heading'>Total lines</td>
      <td class='heading'>Lines of code</td>
      <td class='heading'>Total coverage</td>
      <td class='heading'>Code coverage</td>
      </tr>
    </thead>
  <tbody><tr class='light'><td><a href='-Library-Ruby-Gems-1_8-gems-httpclient-2_1_4-lib-httpclient-http_rb.html'>/Library/Ruby/Gems/1.8/gems/httpclient-2.1.4/lib/httpclient/http.rb</a>
        </td>
      <td class='lines_total'><tt>863</tt>
        </td>
      <td class='lines_code'><tt>584</tt>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_total'>59.2%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='59'/>
                  <td class='uncovered' width='41'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      <td><table cellspacing='0' cellpadding='0' align='right'><tr><td><tt class='coverage_code'>41.4%</tt>
              &nbsp;</td>
            <td><table cellspacing='0' class='percent_graph' cellpadding='0' width='100'><tr><td class='covered' width='41'/>
                  <td class='uncovered' width='59'/>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </td>
      </tr>
    </tbody>
  </table>
<pre><span class="inferred1"><a name="line1"></a>  1 # HTTPClient - HTTP client library.
</span><span class="inferred0"><a name="line2"></a>  2 # Copyright (C) 2000-2009  NAKAMURA, Hiroshi  &lt;nahi@ruby-lang.org&gt;.
</span><span class="inferred1"><a name="line3"></a>  3 #
</span><span class="inferred0"><a name="line4"></a>  4 # This program is copyrighted free software by NAKAMURA, Hiroshi.  You can
</span><span class="inferred1"><a name="line5"></a>  5 # redistribute it and/or modify it under the same terms of Ruby's license;
</span><span class="inferred0"><a name="line6"></a>  6 # either the dual license version in 2003, or any later version.
</span><span class="inferred1"><a name="line7"></a>  7 
</span><span class="inferred0"><a name="line8"></a>  8 
</span><span class="marked1"><a name="line9"></a>  9 require 'time'
</span><span class="inferred0"><a name="line10"></a> 10 
</span><span class="inferred1"><a name="line11"></a> 11 
</span><span class="inferred0"><a name="line12"></a> 12 # A namespace module for HTTP Message definitions used by HTTPClient.
</span><span class="marked1"><a name="line13"></a> 13 module HTTP
</span><span class="inferred0"><a name="line14"></a> 14 
</span><span class="inferred1"><a name="line15"></a> 15 
</span><span class="inferred0"><a name="line16"></a> 16   # Represents HTTP response status code.  Defines constants for HTTP response
</span><span class="inferred1"><a name="line17"></a> 17   # and some conditional methods.
</span><span class="marked0"><a name="line18"></a> 18   module Status
</span><span class="marked1"><a name="line19"></a> 19     OK = 200
</span><span class="marked0"><a name="line20"></a> 20     CREATED = 201
</span><span class="marked1"><a name="line21"></a> 21     ACCEPTED = 202
</span><span class="marked0"><a name="line22"></a> 22     NON_AUTHORITATIVE_INFORMATION = 203
</span><span class="marked1"><a name="line23"></a> 23     NO_CONTENT = 204
</span><span class="marked0"><a name="line24"></a> 24     RESET_CONTENT = 205
</span><span class="marked1"><a name="line25"></a> 25     PARTIAL_CONTENT = 206
</span><span class="marked0"><a name="line26"></a> 26     MOVED_PERMANENTLY = 301
</span><span class="marked1"><a name="line27"></a> 27     FOUND = 302
</span><span class="marked0"><a name="line28"></a> 28     SEE_OTHER = 303
</span><span class="marked1"><a name="line29"></a> 29     TEMPORARY_REDIRECT = MOVED_TEMPORARILY = 307
</span><span class="marked0"><a name="line30"></a> 30     BAD_REQUEST = 400
</span><span class="marked1"><a name="line31"></a> 31     UNAUTHORIZED = 401
</span><span class="marked0"><a name="line32"></a> 32     PROXY_AUTHENTICATE_REQUIRED = 407
</span><span class="marked1"><a name="line33"></a> 33     INTERNAL = 500
</span><span class="inferred0"><a name="line34"></a> 34 
</span><span class="inferred1"><a name="line35"></a> 35     # Status codes for successful HTTP response.
</span><span class="marked0"><a name="line36"></a> 36     SUCCESSFUL_STATUS = [
</span><span class="inferred1"><a name="line37"></a> 37       OK, CREATED, ACCEPTED,
</span><span class="inferred0"><a name="line38"></a> 38       NON_AUTHORITATIVE_INFORMATION, NO_CONTENT,
</span><span class="inferred1"><a name="line39"></a> 39       RESET_CONTENT, PARTIAL_CONTENT
</span><span class="inferred0"><a name="line40"></a> 40     ]
</span><span class="inferred1"><a name="line41"></a> 41 
</span><span class="inferred0"><a name="line42"></a> 42     # Status codes which is a redirect.
</span><span class="marked1"><a name="line43"></a> 43     REDIRECT_STATUS = [
</span><span class="inferred0"><a name="line44"></a> 44       MOVED_PERMANENTLY, FOUND, SEE_OTHER,
</span><span class="inferred1"><a name="line45"></a> 45       TEMPORARY_REDIRECT, MOVED_TEMPORARILY
</span><span class="inferred0"><a name="line46"></a> 46     ]
</span><span class="inferred1"><a name="line47"></a> 47 
</span><span class="inferred0"><a name="line48"></a> 48     # Returns true if the given status represents successful HTTP response.
</span><span class="inferred1"><a name="line49"></a> 49     # See also SUCCESSFUL_STATUS.
</span><span class="marked0"><a name="line50"></a> 50     def self.successful?(status)
</span><span class="uncovered1"><a name="line51"></a> 51       SUCCESSFUL_STATUS.include?(status)
</span><span class="uncovered0"><a name="line52"></a> 52     end
</span><span class="inferred1"><a name="line53"></a> 53 
</span><span class="inferred0"><a name="line54"></a> 54     # Returns true if the given status is thought to be redirect.
</span><span class="inferred1"><a name="line55"></a> 55     # See also REDIRECT_STATUS.
</span><span class="marked0"><a name="line56"></a> 56     def self.redirect?(status)
</span><span class="uncovered1"><a name="line57"></a> 57       REDIRECT_STATUS.include?(status)
</span><span class="uncovered0"><a name="line58"></a> 58     end
</span><span class="uncovered1"><a name="line59"></a> 59   end
</span><span class="inferred0"><a name="line60"></a> 60 
</span><span class="inferred1"><a name="line61"></a> 61 
</span><span class="inferred0"><a name="line62"></a> 62   # Represents a HTTP message.  A message is for a request or a response.
</span><span class="inferred1"><a name="line63"></a> 63   #
</span><span class="inferred0"><a name="line64"></a> 64   # Request message is generated from given parameters internally so users
</span><span class="inferred1"><a name="line65"></a> 65   # don't need to care about it.  Response message is the instance that
</span><span class="inferred0"><a name="line66"></a> 66   # methods of HTTPClient returns so users need to know how to extract
</span><span class="inferred1"><a name="line67"></a> 67   # HTTP response data from Message.
</span><span class="inferred0"><a name="line68"></a> 68   #
</span><span class="inferred1"><a name="line69"></a> 69   # Some attributes are only for a request or a response, not both.
</span><span class="inferred0"><a name="line70"></a> 70   #
</span><span class="inferred1"><a name="line71"></a> 71   # == How to use HTTP response message
</span><span class="inferred0"><a name="line72"></a> 72   #
</span><span class="inferred1"><a name="line73"></a> 73   # 1. Gets response message body.
</span><span class="inferred0"><a name="line74"></a> 74   #
</span><span class="inferred1"><a name="line75"></a> 75   #     res = clnt.get(url)
</span><span class="inferred0"><a name="line76"></a> 76   #     p res.content #=&gt; String
</span><span class="inferred1"><a name="line77"></a> 77   #
</span><span class="inferred0"><a name="line78"></a> 78   # 2. Gets response status code.
</span><span class="inferred1"><a name="line79"></a> 79   #
</span><span class="inferred0"><a name="line80"></a> 80   #     res = clnt.get(url)
</span><span class="inferred1"><a name="line81"></a> 81   #     p res.status #=&gt; 200, 501, etc. (Integer)
</span><span class="inferred0"><a name="line82"></a> 82   #
</span><span class="inferred1"><a name="line83"></a> 83   # 3. Gets response header.
</span><span class="inferred0"><a name="line84"></a> 84   #
</span><span class="inferred1"><a name="line85"></a> 85   #     res = clnt.get(url)
</span><span class="inferred0"><a name="line86"></a> 86   #     res.header['set-cookie'].each do |value|
</span><span class="inferred1"><a name="line87"></a> 87   #       p value
</span><span class="inferred0"><a name="line88"></a> 88   #     end
</span><span class="inferred1"><a name="line89"></a> 89   #     assert_equal(1, res.header['last-modified'].size)
</span><span class="inferred0"><a name="line90"></a> 90   #     p res.header['last-modified'].first
</span><span class="inferred1"><a name="line91"></a> 91   #
</span><span class="marked0"><a name="line92"></a> 92   class Message
</span><span class="inferred1"><a name="line93"></a> 93 
</span><span class="marked0"><a name="line94"></a> 94     CRLF = &quot;\r\n&quot;
</span><span class="inferred1"><a name="line95"></a> 95 
</span><span class="inferred0"><a name="line96"></a> 96     # Represents HTTP message header.
</span><span class="marked1"><a name="line97"></a> 97     class Headers
</span><span class="inferred0"><a name="line98"></a> 98       # HTTP version in a HTTP header.  Float.
</span><span class="marked1"><a name="line99"></a> 99       attr_accessor :http_version
</span><span class="inferred0"><a name="line100"></a>100       # Size of body.  nil when size is unknown (e.g. chunked response).
</span><span class="marked1"><a name="line101"></a>101       attr_reader :body_size
</span><span class="inferred0"><a name="line102"></a>102       # Request/Response is chunked or not.
</span><span class="marked1"><a name="line103"></a>103       attr_accessor :chunked
</span><span class="inferred0"><a name="line104"></a>104 
</span><span class="inferred1"><a name="line105"></a>105       # Request only.  Requested method.
</span><span class="marked0"><a name="line106"></a>106       attr_reader :request_method
</span><span class="inferred1"><a name="line107"></a>107       # Request only.  Requested URI.
</span><span class="marked0"><a name="line108"></a>108       attr_accessor :request_uri
</span><span class="inferred1"><a name="line109"></a>109       # Request only.  Requested query.
</span><span class="marked0"><a name="line110"></a>110       attr_accessor :request_query
</span><span class="inferred1"><a name="line111"></a>111       # Request only.  Requested via proxy or not.
</span><span class="marked0"><a name="line112"></a>112       attr_accessor :request_via_proxy
</span><span class="inferred1"><a name="line113"></a>113 
</span><span class="inferred0"><a name="line114"></a>114       # Response only.  HTTP status
</span><span class="marked1"><a name="line115"></a>115       attr_reader :status_code
</span><span class="inferred0"><a name="line116"></a>116       # Response only.  HTTP status reason phrase.
</span><span class="marked1"><a name="line117"></a>117       attr_accessor :reason_phrase
</span><span class="inferred0"><a name="line118"></a>118 
</span><span class="inferred1"><a name="line119"></a>119       # Used for dumping response.
</span><span class="marked0"><a name="line120"></a>120       attr_accessor :body_type # :nodoc:
</span><span class="inferred1"><a name="line121"></a>121       # Used for dumping response.
</span><span class="marked0"><a name="line122"></a>122       attr_accessor :body_charset # :nodoc:
</span><span class="inferred1"><a name="line123"></a>123       # Used for dumping response.
</span><span class="marked0"><a name="line124"></a>124       attr_accessor :body_date # :nodoc:
</span><span class="inferred1"><a name="line125"></a>125 
</span><span class="inferred0"><a name="line126"></a>126       # HTTP response status code to reason phrase mapping definition.
</span><span class="marked1"><a name="line127"></a>127       STATUS_CODE_MAP = {
</span><span class="inferred0"><a name="line128"></a>128         Status::OK =&gt; 'OK',
</span><span class="inferred1"><a name="line129"></a>129         Status::CREATED =&gt; &quot;Created&quot;,
</span><span class="inferred0"><a name="line130"></a>130         Status::NON_AUTHORITATIVE_INFORMATION =&gt; &quot;Non-Authoritative Information&quot;,
</span><span class="inferred1"><a name="line131"></a>131         Status::NO_CONTENT =&gt; &quot;No Content&quot;,
</span><span class="inferred0"><a name="line132"></a>132         Status::RESET_CONTENT =&gt; &quot;Reset Content&quot;,
</span><span class="inferred1"><a name="line133"></a>133         Status::PARTIAL_CONTENT =&gt; &quot;Partial Content&quot;,
</span><span class="inferred0"><a name="line134"></a>134         Status::MOVED_PERMANENTLY =&gt; 'Moved Permanently',
</span><span class="inferred1"><a name="line135"></a>135         Status::FOUND =&gt; 'Found',
</span><span class="inferred0"><a name="line136"></a>136         Status::SEE_OTHER =&gt; 'See Other',
</span><span class="inferred1"><a name="line137"></a>137         Status::TEMPORARY_REDIRECT =&gt; 'Temporary Redirect',
</span><span class="inferred0"><a name="line138"></a>138         Status::MOVED_TEMPORARILY =&gt; 'Temporary Redirect',
</span><span class="inferred1"><a name="line139"></a>139         Status::BAD_REQUEST =&gt; 'Bad Request',
</span><span class="inferred0"><a name="line140"></a>140         Status::INTERNAL =&gt; 'Internal Server Error',
</span><span class="inferred1"><a name="line141"></a>141       }
</span><span class="inferred0"><a name="line142"></a>142 
</span><span class="inferred1"><a name="line143"></a>143       # $KCODE to charset mapping definition.
</span><span class="marked0"><a name="line144"></a>144       CHARSET_MAP = {
</span><span class="inferred1"><a name="line145"></a>145         'NONE' =&gt; 'us-ascii',
</span><span class="inferred0"><a name="line146"></a>146         'EUC'  =&gt; 'euc-jp',
</span><span class="inferred1"><a name="line147"></a>147         'SJIS' =&gt; 'shift_jis',
</span><span class="inferred0"><a name="line148"></a>148         'UTF8' =&gt; 'utf-8',
</span><span class="inferred1"><a name="line149"></a>149       }
</span><span class="inferred0"><a name="line150"></a>150 
</span><span class="inferred1"><a name="line151"></a>151       # Creates a Message::Headers.  Use init_request, init_response, or
</span><span class="inferred0"><a name="line152"></a>152       # init_connect_request for acutual initialize.
</span><span class="marked1"><a name="line153"></a>153       def initialize
</span><span class="uncovered0"><a name="line154"></a>154         @http_version = 1.1
</span><span class="uncovered1"><a name="line155"></a>155         @body_size = nil
</span><span class="uncovered0"><a name="line156"></a>156         @chunked = false
</span><span class="uncovered1"><a name="line157"></a>157 
</span><span class="uncovered0"><a name="line158"></a>158         @request_method = nil
</span><span class="uncovered1"><a name="line159"></a>159         @request_uri = nil
</span><span class="uncovered0"><a name="line160"></a>160         @request_query = nil
</span><span class="uncovered1"><a name="line161"></a>161         @request_via_proxy = nil
</span><span class="uncovered0"><a name="line162"></a>162 
</span><span class="uncovered1"><a name="line163"></a>163         @status_code = nil
</span><span class="uncovered0"><a name="line164"></a>164         @reason_phrase = nil
</span><span class="uncovered1"><a name="line165"></a>165 
</span><span class="uncovered0"><a name="line166"></a>166         @body_type = nil
</span><span class="uncovered1"><a name="line167"></a>167         @body_charset = nil
</span><span class="uncovered0"><a name="line168"></a>168         @body_date = nil
</span><span class="uncovered1"><a name="line169"></a>169 
</span><span class="uncovered0"><a name="line170"></a>170         @is_request = nil
</span><span class="uncovered1"><a name="line171"></a>171         @header_item = []
</span><span class="uncovered0"><a name="line172"></a>172         @dumped = false
</span><span class="uncovered1"><a name="line173"></a>173       end
</span><span class="inferred0"><a name="line174"></a>174 
</span><span class="inferred1"><a name="line175"></a>175       # Initialize this instance as a CONNECT request.
</span><span class="marked0"><a name="line176"></a>176       def init_connect_request(uri)
</span><span class="uncovered1"><a name="line177"></a>177         @is_request = true
</span><span class="uncovered0"><a name="line178"></a>178         @request_method = 'CONNECT'
</span><span class="uncovered1"><a name="line179"></a>179         @request_uri = uri
</span><span class="uncovered0"><a name="line180"></a>180         @request_query = nil
</span><span class="uncovered1"><a name="line181"></a>181         @http_version = 1.0
</span><span class="uncovered0"><a name="line182"></a>182       end
</span><span class="inferred1"><a name="line183"></a>183 
</span><span class="inferred0"><a name="line184"></a>184       # Placeholder URI object for nil uri.
</span><span class="marked1"><a name="line185"></a>185       NIL_URI = URI.parse('http://nil-uri-given/')
</span><span class="inferred0"><a name="line186"></a>186       # Initialize this instance as a general request.
</span><span class="marked1"><a name="line187"></a>187       def init_request(method, uri, query = nil)
</span><span class="uncovered0"><a name="line188"></a>188         @is_request = true
</span><span class="uncovered1"><a name="line189"></a>189         @request_method = method
</span><span class="uncovered0"><a name="line190"></a>190         @request_uri = uri || NIL_URI
</span><span class="uncovered1"><a name="line191"></a>191         @request_query = query
</span><span class="uncovered0"><a name="line192"></a>192         @request_via_proxy = false
</span><span class="uncovered1"><a name="line193"></a>193       end
</span><span class="inferred0"><a name="line194"></a>194 
</span><span class="inferred1"><a name="line195"></a>195       # Initialize this instance as a response.
</span><span class="marked0"><a name="line196"></a>196       def init_response(status_code)
</span><span class="uncovered1"><a name="line197"></a>197         @is_request = false
</span><span class="uncovered0"><a name="line198"></a>198         self.status_code = status_code
</span><span class="uncovered1"><a name="line199"></a>199       end
</span><span class="inferred0"><a name="line200"></a>200 
</span><span class="inferred1"><a name="line201"></a>201       # Sets status code and reason phrase.
</span><span class="marked0"><a name="line202"></a>202       def status_code=(status_code)
</span><span class="uncovered1"><a name="line203"></a>203         @status_code = status_code
</span><span class="uncovered0"><a name="line204"></a>204         @reason_phrase = STATUS_CODE_MAP[@status_code]
</span><span class="uncovered1"><a name="line205"></a>205       end
</span><span class="inferred0"><a name="line206"></a>206 
</span><span class="inferred1"><a name="line207"></a>207       # Returns 'Content-Type' header value.
</span><span class="marked0"><a name="line208"></a>208       def contenttype
</span><span class="uncovered1"><a name="line209"></a>209         self['Content-Type'][0]
</span><span class="uncovered0"><a name="line210"></a>210       end
</span><span class="inferred1"><a name="line211"></a>211 
</span><span class="inferred0"><a name="line212"></a>212       # Sets 'Content-Type' header value.  Overrides if already exists.
</span><span class="marked1"><a name="line213"></a>213       def contenttype=(contenttype)
</span><span class="uncovered0"><a name="line214"></a>214         delete('Content-Type')
</span><span class="uncovered1"><a name="line215"></a>215         self['Content-Type'] = contenttype
</span><span class="uncovered0"><a name="line216"></a>216       end
</span><span class="inferred1"><a name="line217"></a>217 
</span><span class="inferred0"><a name="line218"></a>218       # Sets byte size of message body.
</span><span class="inferred1"><a name="line219"></a>219       # body_size == nil means that the body is_a? IO
</span><span class="marked0"><a name="line220"></a>220       def body_size=(body_size)
</span><span class="uncovered1"><a name="line221"></a>221         @body_size = body_size
</span><span class="uncovered0"><a name="line222"></a>222       end
</span><span class="inferred1"><a name="line223"></a>223 
</span><span class="inferred0"><a name="line224"></a>224       # Dumps message header part and returns a dumped String.
</span><span class="marked1"><a name="line225"></a>225       def dump
</span><span class="uncovered0"><a name="line226"></a>226         set_header
</span><span class="uncovered1"><a name="line227"></a>227         str = nil
</span><span class="uncovered0"><a name="line228"></a>228         if @is_request
</span><span class="uncovered1"><a name="line229"></a>229           str = request_line
</span><span class="uncovered0"><a name="line230"></a>230         else
</span><span class="uncovered1"><a name="line231"></a>231           str = response_status_line
</span><span class="uncovered0"><a name="line232"></a>232         end
</span><span class="uncovered1"><a name="line233"></a>233         str + @header_item.collect { |key, value|
</span><span class="uncovered0"><a name="line234"></a>234           &quot;#{ key }: #{ value }#{ CRLF }&quot;
</span><span class="uncovered1"><a name="line235"></a>235         }.join
</span><span class="uncovered0"><a name="line236"></a>236       end
</span><span class="inferred1"><a name="line237"></a>237 
</span><span class="inferred0"><a name="line238"></a>238       # Adds a header.  Addition order is preserved.
</span><span class="marked1"><a name="line239"></a>239       def add(key, value)
</span><span class="uncovered0"><a name="line240"></a>240         if value.is_a?(Array)
</span><span class="uncovered1"><a name="line241"></a>241           value.each do |v|
</span><span class="uncovered0"><a name="line242"></a>242             @header_item.push([key, v])
</span><span class="uncovered1"><a name="line243"></a>243           end
</span><span class="uncovered0"><a name="line244"></a>244         else
</span><span class="uncovered1"><a name="line245"></a>245           @header_item.push([key, value])
</span><span class="uncovered0"><a name="line246"></a>246         end
</span><span class="uncovered1"><a name="line247"></a>247       end
</span><span class="inferred0"><a name="line248"></a>248 
</span><span class="inferred1"><a name="line249"></a>249       # Sets a header.
</span><span class="marked0"><a name="line250"></a>250       def set(key, value)
</span><span class="uncovered1"><a name="line251"></a>251         delete(key)
</span><span class="uncovered0"><a name="line252"></a>252         add(key, value)
</span><span class="uncovered1"><a name="line253"></a>253       end
</span><span class="inferred0"><a name="line254"></a>254 
</span><span class="inferred1"><a name="line255"></a>255       # Returns an Array of headers for the given key.  Each element is a pair
</span><span class="inferred0"><a name="line256"></a>256       # of key and value.  It returns an single element Array even if the only
</span><span class="inferred1"><a name="line257"></a>257       # one header exists.  If nil key given, it returns all headers.
</span><span class="marked0"><a name="line258"></a>258       def get(key = nil)
</span><span class="uncovered1"><a name="line259"></a>259         if key.nil?
</span><span class="uncovered0"><a name="line260"></a>260           all
</span><span class="uncovered1"><a name="line261"></a>261         else
</span><span class="uncovered0"><a name="line262"></a>262           key = key.upcase
</span><span class="uncovered1"><a name="line263"></a>263           @header_item.find_all { |k, v| k.upcase == key }
</span><span class="uncovered0"><a name="line264"></a>264         end
</span><span class="uncovered1"><a name="line265"></a>265       end
</span><span class="inferred0"><a name="line266"></a>266 
</span><span class="inferred1"><a name="line267"></a>267       # Returns an Array of all headers.
</span><span class="marked0"><a name="line268"></a>268       def all
</span><span class="uncovered1"><a name="line269"></a>269         @header_item
</span><span class="uncovered0"><a name="line270"></a>270       end
</span><span class="inferred1"><a name="line271"></a>271 
</span><span class="inferred0"><a name="line272"></a>272       # Deletes headers of the given key.
</span><span class="marked1"><a name="line273"></a>273       def delete(key)
</span><span class="uncovered0"><a name="line274"></a>274         key = key.upcase
</span><span class="uncovered1"><a name="line275"></a>275         @header_item.delete_if { |k, v| k.upcase == key }
</span><span class="uncovered0"><a name="line276"></a>276       end
</span><span class="inferred1"><a name="line277"></a>277 
</span><span class="inferred0"><a name="line278"></a>278       # Adds a header.  See set.
</span><span class="marked1"><a name="line279"></a>279       def []=(key, value)
</span><span class="uncovered0"><a name="line280"></a>280         set(key, value)
</span><span class="uncovered1"><a name="line281"></a>281       end
</span><span class="inferred0"><a name="line282"></a>282 
</span><span class="inferred1"><a name="line283"></a>283       # Returns an Array of header values for the given key.
</span><span class="marked0"><a name="line284"></a>284       def [](key)
</span><span class="uncovered1"><a name="line285"></a>285         get(key).collect { |item| item[1] }
</span><span class="uncovered0"><a name="line286"></a>286       end
</span><span class="inferred1"><a name="line287"></a>287 
</span><span class="marked0"><a name="line288"></a>288     private
</span><span class="inferred1"><a name="line289"></a>289 
</span><span class="marked0"><a name="line290"></a>290       def request_line
</span><span class="uncovered1"><a name="line291"></a>291         path = create_query_uri(@request_uri, @request_query)
</span><span class="uncovered0"><a name="line292"></a>292         if @request_via_proxy
</span><span class="uncovered1"><a name="line293"></a>293           path = &quot;#{ @request_uri.scheme }://#{ @request_uri.host }:#{ @request_uri.port }#{ path }&quot;
</span><span class="uncovered0"><a name="line294"></a>294         end
</span><span class="uncovered1"><a name="line295"></a>295         &quot;#{ @request_method } #{ path } HTTP/#{ @http_version }#{ CRLF }&quot;
</span><span class="uncovered0"><a name="line296"></a>296       end
</span><span class="inferred1"><a name="line297"></a>297 
</span><span class="marked0"><a name="line298"></a>298       def response_status_line
</span><span class="uncovered1"><a name="line299"></a>299         if defined?(Apache)
</span><span class="uncovered0"><a name="line300"></a>300           &quot;HTTP/#{ @http_version } #{ @status_code } #{ @reason_phrase }#{ CRLF }&quot;
</span><span class="uncovered1"><a name="line301"></a>301         else
</span><span class="uncovered0"><a name="line302"></a>302           &quot;Status: #{ @status_code } #{ @reason_phrase }#{ CRLF }&quot;
</span><span class="uncovered1"><a name="line303"></a>303         end
</span><span class="uncovered0"><a name="line304"></a>304       end
</span><span class="inferred1"><a name="line305"></a>305 
</span><span class="marked0"><a name="line306"></a>306       def set_header
</span><span class="uncovered1"><a name="line307"></a>307         if @is_request
</span><span class="uncovered0"><a name="line308"></a>308           set_request_header
</span><span class="uncovered1"><a name="line309"></a>309         else
</span><span class="uncovered0"><a name="line310"></a>310           set_response_header
</span><span class="uncovered1"><a name="line311"></a>311         end
</span><span class="uncovered0"><a name="line312"></a>312       end
</span><span class="inferred1"><a name="line313"></a>313 
</span><span class="marked0"><a name="line314"></a>314       def set_request_header
</span><span class="uncovered1"><a name="line315"></a>315         return if @dumped
</span><span class="uncovered0"><a name="line316"></a>316         @dumped = true
</span><span class="uncovered1"><a name="line317"></a>317         keep_alive = Message.keep_alive_enabled?(@http_version)
</span><span class="uncovered0"><a name="line318"></a>318         if !keep_alive and @request_method != 'CONNECT'
</span><span class="uncovered1"><a name="line319"></a>319           set('Connection', 'close')
</span><span class="uncovered0"><a name="line320"></a>320         end
</span><span class="uncovered1"><a name="line321"></a>321         if @chunked
</span><span class="uncovered0"><a name="line322"></a>322           set('Transfer-Encoding', 'chunked')
</span><span class="uncovered1"><a name="line323"></a>323         elsif keep_alive or @body_size != 0
</span><span class="uncovered0"><a name="line324"></a>324           set('Content-Length', @body_size.to_s)
</span><span class="uncovered1"><a name="line325"></a>325         end
</span><span class="uncovered0"><a name="line326"></a>326         if @http_version &gt;= 1.1
</span><span class="uncovered1"><a name="line327"></a>327           if @request_uri.port == @request_uri.default_port
</span><span class="uncovered0"><a name="line328"></a>328             # GFE/1.3 dislikes default port number (returns 404)
</span><span class="uncovered1"><a name="line329"></a>329             set('Host', &quot;#{@request_uri.host}&quot;)
</span><span class="uncovered0"><a name="line330"></a>330           else
</span><span class="uncovered1"><a name="line331"></a>331             set('Host', &quot;#{@request_uri.host}:#{@request_uri.port}&quot;)
</span><span class="uncovered0"><a name="line332"></a>332           end
</span><span class="uncovered1"><a name="line333"></a>333         end
</span><span class="uncovered0"><a name="line334"></a>334       end
</span><span class="inferred1"><a name="line335"></a>335 
</span><span class="marked0"><a name="line336"></a>336       def set_response_header
</span><span class="uncovered1"><a name="line337"></a>337         return if @dumped
</span><span class="uncovered0"><a name="line338"></a>338         @dumped = true
</span><span class="uncovered1"><a name="line339"></a>339         if defined?(Apache) &amp;&amp; self['Date'].empty?
</span><span class="uncovered0"><a name="line340"></a>340           set('Date', Time.now.httpdate)
</span><span class="uncovered1"><a name="line341"></a>341         end
</span><span class="uncovered0"><a name="line342"></a>342         keep_alive = Message.keep_alive_enabled?(@http_version)
</span><span class="uncovered1"><a name="line343"></a>343         if @chunked
</span><span class="uncovered0"><a name="line344"></a>344           set('Transfer-Encoding', 'chunked')
</span><span class="uncovered1"><a name="line345"></a>345         else
</span><span class="uncovered0"><a name="line346"></a>346           if keep_alive or @body_size != 0
</span><span class="uncovered1"><a name="line347"></a>347             set('Content-Length', @body_size.to_s)
</span><span class="uncovered0"><a name="line348"></a>348           end
</span><span class="uncovered1"><a name="line349"></a>349         end
</span><span class="uncovered0"><a name="line350"></a>350         if @body_date
</span><span class="uncovered1"><a name="line351"></a>351           set('Last-Modified', @body_date.httpdate)
</span><span class="uncovered0"><a name="line352"></a>352         end
</span><span class="uncovered1"><a name="line353"></a>353         if self['Content-Type'].empty?
</span><span class="uncovered0"><a name="line354"></a>354           set('Content-Type', &quot;#{ @body_type || 'text/html' }; charset=#{ charset_label(@body_charset || $KCODE) }&quot;)
</span><span class="uncovered1"><a name="line355"></a>355         end
</span><span class="uncovered0"><a name="line356"></a>356       end
</span><span class="inferred1"><a name="line357"></a>357 
</span><span class="marked0"><a name="line358"></a>358       def charset_label(charset)
</span><span class="uncovered1"><a name="line359"></a>359         CHARSET_MAP[charset] || 'us-ascii'
</span><span class="uncovered0"><a name="line360"></a>360       end
</span><span class="inferred1"><a name="line361"></a>361 
</span><span class="marked0"><a name="line362"></a>362       def create_query_uri(uri, query)
</span><span class="uncovered1"><a name="line363"></a>363         if @request_method == 'CONNECT'
</span><span class="uncovered0"><a name="line364"></a>364           return &quot;#{uri.host}:#{uri.port}&quot;
</span><span class="uncovered1"><a name="line365"></a>365         end
</span><span class="uncovered0"><a name="line366"></a>366         path = uri.path
</span><span class="uncovered1"><a name="line367"></a>367         path = '/' if path.nil? or path.empty?
</span><span class="uncovered0"><a name="line368"></a>368         query_str = nil
</span><span class="uncovered1"><a name="line369"></a>369         if uri.query
</span><span class="uncovered0"><a name="line370"></a>370           query_str = uri.query
</span><span class="uncovered1"><a name="line371"></a>371         end
</span><span class="uncovered0"><a name="line372"></a>372         if query
</span><span class="uncovered1"><a name="line373"></a>373           if query_str
</span><span class="uncovered0"><a name="line374"></a>374             query_str += &quot;&amp;#{Message.create_query_part_str(query)}&quot;
</span><span class="uncovered1"><a name="line375"></a>375           else
</span><span class="uncovered0"><a name="line376"></a>376             query_str = Message.create_query_part_str(query)
</span><span class="uncovered1"><a name="line377"></a>377           end
</span><span class="uncovered0"><a name="line378"></a>378         end
</span><span class="uncovered1"><a name="line379"></a>379         if query_str
</span><span class="uncovered0"><a name="line380"></a>380           path += &quot;?#{query_str}&quot;
</span><span class="uncovered1"><a name="line381"></a>381         end
</span><span class="uncovered0"><a name="line382"></a>382         path
</span><span class="uncovered1"><a name="line383"></a>383       end
</span><span class="uncovered0"><a name="line384"></a>384     end
</span><span class="inferred1"><a name="line385"></a>385 
</span><span class="inferred0"><a name="line386"></a>386 
</span><span class="inferred1"><a name="line387"></a>387     # Represents HTTP message body.
</span><span class="marked0"><a name="line388"></a>388     class Body
</span><span class="inferred1"><a name="line389"></a>389       # Size of body.  nil when size is unknown (e.g. chunked response).
</span><span class="marked0"><a name="line390"></a>390       attr_reader :size
</span><span class="inferred1"><a name="line391"></a>391       # maxbytes of IO#read for streaming request.  See DEFAULT_CHUNK_SIZE.
</span><span class="marked0"><a name="line392"></a>392       attr_accessor :chunk_size
</span><span class="inferred1"><a name="line393"></a>393 
</span><span class="inferred0"><a name="line394"></a>394       # Default value for chunk_size
</span><span class="marked1"><a name="line395"></a>395       DEFAULT_CHUNK_SIZE = 1024 * 16
</span><span class="inferred0"><a name="line396"></a>396 
</span><span class="inferred1"><a name="line397"></a>397       # Creates a Message::Body.  Use init_request or init_response
</span><span class="inferred0"><a name="line398"></a>398       # for acutual initialize.
</span><span class="marked1"><a name="line399"></a>399       def initialize
</span><span class="uncovered0"><a name="line400"></a>400         @body = nil
</span><span class="uncovered1"><a name="line401"></a>401         @size = nil
</span><span class="uncovered0"><a name="line402"></a>402         @positions = nil
</span><span class="uncovered1"><a name="line403"></a>403         @chunk_size = nil
</span><span class="uncovered0"><a name="line404"></a>404       end
</span><span class="inferred1"><a name="line405"></a>405 
</span><span class="inferred0"><a name="line406"></a>406       # Initialize this instance as a request.
</span><span class="marked1"><a name="line407"></a>407       def init_request(body = nil, boundary = nil)
</span><span class="uncovered0"><a name="line408"></a>408         @boundary = boundary
</span><span class="uncovered1"><a name="line409"></a>409         @positions = {}
</span><span class="uncovered0"><a name="line410"></a>410         set_content(body, boundary)
</span><span class="uncovered1"><a name="line411"></a>411         @chunk_size = DEFAULT_CHUNK_SIZE
</span><span class="uncovered0"><a name="line412"></a>412       end
</span><span class="inferred1"><a name="line413"></a>413 
</span><span class="inferred0"><a name="line414"></a>414       # Initialize this instance as a response.
</span><span class="marked1"><a name="line415"></a>415       def init_response(body = nil)
</span><span class="uncovered0"><a name="line416"></a>416         @body = body
</span><span class="uncovered1"><a name="line417"></a>417         if @body.respond_to?(:size)
</span><span class="uncovered0"><a name="line418"></a>418           @size = @body.size
</span><span class="uncovered1"><a name="line419"></a>419         else
</span><span class="uncovered0"><a name="line420"></a>420           @size = nil
</span><span class="uncovered1"><a name="line421"></a>421         end
</span><span class="uncovered0"><a name="line422"></a>422       end
</span><span class="inferred1"><a name="line423"></a>423 
</span><span class="inferred0"><a name="line424"></a>424       # Dumps message body to given dev.
</span><span class="inferred1"><a name="line425"></a>425       # dev needs to respond to &lt;&lt;.
</span><span class="inferred0"><a name="line426"></a>426       #
</span><span class="inferred1"><a name="line427"></a>427       # Message header must be given as the first argument for performance
</span><span class="inferred0"><a name="line428"></a>428       # reason. (header is dumped to dev, too)
</span><span class="inferred1"><a name="line429"></a>429       # If no dev (the second argument) given, this method returns a dumped
</span><span class="inferred0"><a name="line430"></a>430       # String.
</span><span class="marked1"><a name="line431"></a>431       def dump(header = '', dev = '')
</span><span class="uncovered0"><a name="line432"></a>432         if @body.is_a?(Parts)
</span><span class="uncovered1"><a name="line433"></a>433           dev &lt;&lt; header
</span><span class="uncovered0"><a name="line434"></a>434           buf = ''
</span><span class="uncovered1"><a name="line435"></a>435           @body.parts.each do |part|
</span><span class="uncovered0"><a name="line436"></a>436             if Message.file?(part)
</span><span class="uncovered1"><a name="line437"></a>437               reset_pos(part)
</span><span class="uncovered0"><a name="line438"></a>438               while !part.read(@chunk_size, buf).nil?
</span><span class="uncovered1"><a name="line439"></a>439                 dev &lt;&lt; buf
</span><span class="uncovered0"><a name="line440"></a>440               end
</span><span class="uncovered1"><a name="line441"></a>441             else
</span><span class="uncovered0"><a name="line442"></a>442               dev &lt;&lt; part
</span><span class="uncovered1"><a name="line443"></a>443             end
</span><span class="uncovered0"><a name="line444"></a>444           end
</span><span class="uncovered1"><a name="line445"></a>445         elsif @body
</span><span class="uncovered0"><a name="line446"></a>446           dev &lt;&lt; header + @body
</span><span class="uncovered1"><a name="line447"></a>447         else
</span><span class="uncovered0"><a name="line448"></a>448           dev &lt;&lt; header
</span><span class="uncovered1"><a name="line449"></a>449         end
</span><span class="uncovered0"><a name="line450"></a>450         dev
</span><span class="uncovered1"><a name="line451"></a>451       end
</span><span class="inferred0"><a name="line452"></a>452 
</span><span class="inferred1"><a name="line453"></a>453       # Dumps message body with chunked encoding to given dev.
</span><span class="inferred0"><a name="line454"></a>454       # dev needs to respond to &lt;&lt;.
</span><span class="inferred1"><a name="line455"></a>455       #
</span><span class="inferred0"><a name="line456"></a>456       # Message header must be given as the first argument for performance
</span><span class="inferred1"><a name="line457"></a>457       # reason. (header is dumped to dev, too)
</span><span class="inferred0"><a name="line458"></a>458       # If no dev (the second argument) given, this method returns a dumped
</span><span class="inferred1"><a name="line459"></a>459       # String.
</span><span class="marked0"><a name="line460"></a>460       def dump_chunked(header = '', dev = '')
</span><span class="uncovered1"><a name="line461"></a>461         dev &lt;&lt; header
</span><span class="uncovered0"><a name="line462"></a>462         if @body.is_a?(Parts)
</span><span class="uncovered1"><a name="line463"></a>463           @body.parts.each do |part|
</span><span class="uncovered0"><a name="line464"></a>464             if Message.file?(part)
</span><span class="uncovered1"><a name="line465"></a>465               reset_pos(part)
</span><span class="uncovered0"><a name="line466"></a>466               dump_chunks(part, dev)
</span><span class="uncovered1"><a name="line467"></a>467             else
</span><span class="uncovered0"><a name="line468"></a>468               dev &lt;&lt; dump_chunk(part)
</span><span class="uncovered1"><a name="line469"></a>469             end
</span><span class="uncovered0"><a name="line470"></a>470           end
</span><span class="uncovered1"><a name="line471"></a>471           dev &lt;&lt; (dump_last_chunk + CRLF)
</span><span class="uncovered0"><a name="line472"></a>472         elsif @body
</span><span class="uncovered1"><a name="line473"></a>473           reset_pos(@body)
</span><span class="uncovered0"><a name="line474"></a>474           dump_chunks(@body, dev)
</span><span class="uncovered1"><a name="line475"></a>475           dev &lt;&lt; (dump_last_chunk + CRLF)
</span><span class="uncovered0"><a name="line476"></a>476         end
</span><span class="uncovered1"><a name="line477"></a>477         dev
</span><span class="uncovered0"><a name="line478"></a>478       end
</span><span class="inferred1"><a name="line479"></a>479 
</span><span class="inferred0"><a name="line480"></a>480       # Returns a message body itself.
</span><span class="marked1"><a name="line481"></a>481       def content
</span><span class="uncovered0"><a name="line482"></a>482         @body
</span><span class="uncovered1"><a name="line483"></a>483       end
</span><span class="inferred0"><a name="line484"></a>484 
</span><span class="marked1"><a name="line485"></a>485     private
</span><span class="inferred0"><a name="line486"></a>486 
</span><span class="marked1"><a name="line487"></a>487       def set_content(body, boundary = nil)
</span><span class="uncovered0"><a name="line488"></a>488         if body.respond_to?(:read)
</span><span class="uncovered1"><a name="line489"></a>489           # uses Transfer-Encoding: chunked.  bear in mind that server may not
</span><span class="uncovered0"><a name="line490"></a>490           # support it.  at least ruby's CGI doesn't.
</span><span class="uncovered1"><a name="line491"></a>491           @body = body
</span><span class="uncovered0"><a name="line492"></a>492           remember_pos(@body)
</span><span class="uncovered1"><a name="line493"></a>493           @size = nil
</span><span class="uncovered0"><a name="line494"></a>494         elsif boundary and Message.multiparam_query?(body)
</span><span class="uncovered1"><a name="line495"></a>495           @body = build_query_multipart_str(body, boundary)
</span><span class="uncovered0"><a name="line496"></a>496           @size = @body.size
</span><span class="uncovered1"><a name="line497"></a>497         else
</span><span class="uncovered0"><a name="line498"></a>498           @body = Message.create_query_part_str(body)
</span><span class="uncovered1"><a name="line499"></a>499           @size = @body.size
</span><span class="uncovered0"><a name="line500"></a>500         end
</span><span class="uncovered1"><a name="line501"></a>501       end
</span><span class="inferred0"><a name="line502"></a>502 
</span><span class="marked1"><a name="line503"></a>503       def remember_pos(io)
</span><span class="uncovered0"><a name="line504"></a>504         # IO may not support it (ex. IO.pipe)
</span><span class="uncovered1"><a name="line505"></a>505         @positions[io] = io.pos rescue nil
</span><span class="uncovered0"><a name="line506"></a>506       end
</span><span class="inferred1"><a name="line507"></a>507 
</span><span class="marked0"><a name="line508"></a>508       def reset_pos(io)
</span><span class="uncovered1"><a name="line509"></a>509         io.pos = @positions[io] if @positions.key?(io)
</span><span class="uncovered0"><a name="line510"></a>510       end
</span><span class="inferred1"><a name="line511"></a>511 
</span><span class="marked0"><a name="line512"></a>512       def dump_chunks(io, dev)
</span><span class="uncovered1"><a name="line513"></a>513         buf = ''
</span><span class="uncovered0"><a name="line514"></a>514         while !io.read(@chunk_size, buf).nil?
</span><span class="uncovered1"><a name="line515"></a>515           dev &lt;&lt; dump_chunk(buf)
</span><span class="uncovered0"><a name="line516"></a>516         end
</span><span class="uncovered1"><a name="line517"></a>517       end
</span><span class="inferred0"><a name="line518"></a>518 
</span><span class="marked1"><a name="line519"></a>519       def dump_chunk(str)
</span><span class="uncovered0"><a name="line520"></a>520         dump_chunk_size(str.size) + (str + CRLF)
</span><span class="uncovered1"><a name="line521"></a>521       end
</span><span class="inferred0"><a name="line522"></a>522 
</span><span class="marked1"><a name="line523"></a>523       def dump_last_chunk
</span><span class="uncovered0"><a name="line524"></a>524         dump_chunk_size(0)
</span><span class="uncovered1"><a name="line525"></a>525       end
</span><span class="inferred0"><a name="line526"></a>526 
</span><span class="marked1"><a name="line527"></a>527       def dump_chunk_size(size)
</span><span class="inferred0"><a name="line528"></a>528         sprintf(&quot;%x&quot;, size) + CRLF
</span><span class="inferred1"><a name="line529"></a>529       end
</span><span class="inferred0"><a name="line530"></a>530 
</span><span class="marked1"><a name="line531"></a>531       class Parts
</span><span class="marked0"><a name="line532"></a>532         attr_reader :size
</span><span class="inferred1"><a name="line533"></a>533 
</span><span class="marked0"><a name="line534"></a>534         def initialize
</span><span class="inferred1"><a name="line535"></a>535           @body = []
</span><span class="inferred0"><a name="line536"></a>536           @size = 0
</span><span class="inferred1"><a name="line537"></a>537           @as_stream = false
</span><span class="inferred0"><a name="line538"></a>538         end
</span><span class="inferred1"><a name="line539"></a>539 
</span><span class="marked0"><a name="line540"></a>540         def add(part)
</span><span class="inferred1"><a name="line541"></a>541           if Message.file?(part)
</span><span class="inferred0"><a name="line542"></a>542             @as_stream = true
</span><span class="inferred1"><a name="line543"></a>543             @body &lt;&lt; part
</span><span class="inferred0"><a name="line544"></a>544             if part.respond_to?(:size)
</span><span class="inferred1"><a name="line545"></a>545               if sz = part.size
</span><span class="inferred0"><a name="line546"></a>546                 @size += sz
</span><span class="inferred1"><a name="line547"></a>547               else
</span><span class="inferred0"><a name="line548"></a>548                 @size = nil
</span><span class="inferred1"><a name="line549"></a>549               end
</span><span class="inferred0"><a name="line550"></a>550             elsif part.respond_to?(:lstat)
</span><span class="inferred1"><a name="line551"></a>551               @size += part.lstat.size
</span><span class="inferred0"><a name="line552"></a>552             else
</span><span class="inferred1"><a name="line553"></a>553               # use chunked upload
</span><span class="inferred0"><a name="line554"></a>554               @size = nil
</span><span class="inferred1"><a name="line555"></a>555             end
</span><span class="inferred0"><a name="line556"></a>556           elsif @body[-1].is_a?(String)
</span><span class="inferred1"><a name="line557"></a>557             @body[-1] += part.to_s
</span><span class="inferred0"><a name="line558"></a>558             @size += part.to_s.size if @size
</span><span class="inferred1"><a name="line559"></a>559           else
</span><span class="inferred0"><a name="line560"></a>560             @body &lt;&lt; part.to_s
</span><span class="inferred1"><a name="line561"></a>561             @size += part.to_s.size if @size
</span><span class="inferred0"><a name="line562"></a>562           end
</span><span class="inferred1"><a name="line563"></a>563         end
</span><span class="inferred0"><a name="line564"></a>564 
</span><span class="marked1"><a name="line565"></a>565         def parts
</span><span class="inferred0"><a name="line566"></a>566           if @as_stream
</span><span class="inferred1"><a name="line567"></a>567             @body
</span><span class="inferred0"><a name="line568"></a>568           else
</span><span class="inferred1"><a name="line569"></a>569             [@body.join]
</span><span class="inferred0"><a name="line570"></a>570           end
</span><span class="inferred1"><a name="line571"></a>571         end
</span><span class="inferred0"><a name="line572"></a>572       end
</span><span class="inferred1"><a name="line573"></a>573 
</span><span class="marked0"><a name="line574"></a>574       def build_query_multipart_str(query, boundary)
</span><span class="inferred1"><a name="line575"></a>575         parts = Parts.new
</span><span class="inferred0"><a name="line576"></a>576         query.each do |attr, value|
</span><span class="inferred1"><a name="line577"></a>577           value ||= ''
</span><span class="inferred0"><a name="line578"></a>578           headers = [&quot;--#{boundary}&quot;]
</span><span class="inferred1"><a name="line579"></a>579           if Message.file?(value)
</span><span class="inferred0"><a name="line580"></a>580             remember_pos(value)
</span><span class="inferred1"><a name="line581"></a>581             param_str = params_from_file(value).collect { |k, v|
</span><span class="inferred0"><a name="line582"></a>582               &quot;#{k}=\&quot;#{v}\&quot;&quot;
</span><span class="inferred1"><a name="line583"></a>583             }.join(&quot;; &quot;)
</span><span class="inferred0"><a name="line584"></a>584             if value.respond_to?(:mime_type)
</span><span class="inferred1"><a name="line585"></a>585               content_type = value.mime_type
</span><span class="inferred0"><a name="line586"></a>586             else
</span><span class="inferred1"><a name="line587"></a>587               content_type = Message.mime_type(value.path)
</span><span class="inferred0"><a name="line588"></a>588             end
</span><span class="inferred1"><a name="line589"></a>589             headers &lt;&lt; %{Content-Disposition: form-data; name=&quot;#{attr}&quot;; #{param_str}}
</span><span class="inferred0"><a name="line590"></a>590             headers &lt;&lt; %{Content-Type: #{content_type}}
</span><span class="inferred1"><a name="line591"></a>591           else
</span><span class="inferred0"><a name="line592"></a>592             headers &lt;&lt; %{Content-Disposition: form-data; name=&quot;#{attr}&quot;}
</span><span class="inferred1"><a name="line593"></a>593           end
</span><span class="inferred0"><a name="line594"></a>594           parts.add(headers.join(CRLF) + CRLF + CRLF)
</span><span class="inferred1"><a name="line595"></a>595           parts.add(value)
</span><span class="inferred0"><a name="line596"></a>596           parts.add(CRLF)
</span><span class="inferred1"><a name="line597"></a>597         end
</span><span class="inferred0"><a name="line598"></a>598         parts.add(&quot;--#{boundary}--&quot; + CRLF + CRLF) # empty epilogue
</span><span class="inferred1"><a name="line599"></a>599         parts
</span><span class="inferred0"><a name="line600"></a>600       end
</span><span class="inferred1"><a name="line601"></a>601 
</span><span class="marked0"><a name="line602"></a>602       def params_from_file(value)
</span><span class="inferred1"><a name="line603"></a>603         params = {}
</span><span class="inferred0"><a name="line604"></a>604         params['filename'] = File.basename(value.path || '')
</span><span class="inferred1"><a name="line605"></a>605         # Creation time is not available from File::Stat
</span><span class="inferred0"><a name="line606"></a>606         if value.respond_to?(:mtime)
</span><span class="inferred1"><a name="line607"></a>607           params['modification-date'] = value.mtime.rfc822
</span><span class="inferred0"><a name="line608"></a>608         end
</span><span class="inferred1"><a name="line609"></a>609         if value.respond_to?(:atime)
</span><span class="inferred0"><a name="line610"></a>610           params['read-date'] = value.atime.rfc822
</span><span class="inferred1"><a name="line611"></a>611         end
</span><span class="inferred0"><a name="line612"></a>612         params
</span><span class="inferred1"><a name="line613"></a>613       end
</span><span class="inferred0"><a name="line614"></a>614     end
</span><span class="inferred1"><a name="line615"></a>615 
</span><span class="inferred0"><a name="line616"></a>616 
</span><span class="marked1"><a name="line617"></a>617     class &lt;&lt; self
</span><span class="marked0"><a name="line618"></a>618       private :new
</span><span class="inferred1"><a name="line619"></a>619 
</span><span class="inferred0"><a name="line620"></a>620       # Creates a Message instance of 'CONNECT' request.
</span><span class="inferred1"><a name="line621"></a>621       # 'CONNECT' request does not have Body.
</span><span class="inferred0"><a name="line622"></a>622       # uri:: an URI that need to connect.  Only uri.host and uri.port are used.
</span><span class="marked1"><a name="line623"></a>623       def new_connect_request(uri)
</span><span class="inferred0"><a name="line624"></a>624         m = new
</span><span class="inferred1"><a name="line625"></a>625         m.header.init_connect_request(uri)
</span><span class="inferred0"><a name="line626"></a>626         m.header.body_size = 0
</span><span class="inferred1"><a name="line627"></a>627         m
</span><span class="inferred0"><a name="line628"></a>628       end
</span><span class="inferred1"><a name="line629"></a>629 
</span><span class="inferred0"><a name="line630"></a>630       # Creates a Message instance of general request.
</span><span class="inferred1"><a name="line631"></a>631       # method:: HTTP method String.
</span><span class="inferred0"><a name="line632"></a>632       # uri:: an URI object which represents an URL of web resource.
</span><span class="inferred1"><a name="line633"></a>633       # query:: a Hash or an Array of query part of URL.
</span><span class="inferred0"><a name="line634"></a>634       #         e.g. { &quot;a&quot; =&gt; &quot;b&quot; } =&gt; 'http://host/part?a=b'
</span><span class="inferred1"><a name="line635"></a>635       #         Give an array to pass multiple value like
</span><span class="inferred0"><a name="line636"></a>636       #         [[&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;c&quot;]] =&gt; 'http://host/part?a=b&amp;a=c'
</span><span class="inferred1"><a name="line637"></a>637       # body:: a Hash or an Array of body part.
</span><span class="inferred0"><a name="line638"></a>638       #        e.g. { &quot;a&quot; =&gt; &quot;b&quot; } =&gt; 'a=b'.
</span><span class="inferred1"><a name="line639"></a>639       #        Give an array to pass multiple value like
</span><span class="inferred0"><a name="line640"></a>640       #        [[&quot;a&quot;, &quot;b&quot;], [&quot;a&quot;, &quot;c&quot;]] =&gt; 'a=b&amp;a=c'.
</span><span class="inferred1"><a name="line641"></a>641       # boundary:: When the boundary given, it is sent as
</span><span class="inferred0"><a name="line642"></a>642       #            a multipart/form-data using this boundary String.
</span><span class="marked1"><a name="line643"></a>643       def new_request(method, uri, query = nil, body = nil, boundary = nil)
</span><span class="inferred0"><a name="line644"></a>644         m = new
</span><span class="inferred1"><a name="line645"></a>645         m.header.init_request(method, uri, query)
</span><span class="inferred0"><a name="line646"></a>646         m.body = Body.new
</span><span class="inferred1"><a name="line647"></a>647         m.body.init_request(body || '', boundary)
</span><span class="inferred0"><a name="line648"></a>648         m.header.body_size = m.body.size
</span><span class="inferred1"><a name="line649"></a>649         m.header.chunked = true if m.body.size.nil?
</span><span class="inferred0"><a name="line650"></a>650         m
</span><span class="inferred1"><a name="line651"></a>651       end
</span><span class="inferred0"><a name="line652"></a>652 
</span><span class="inferred1"><a name="line653"></a>653       # Creates a Message instance of response.
</span><span class="inferred0"><a name="line654"></a>654       # body:: a String or an IO of response message body.
</span><span class="marked1"><a name="line655"></a>655       def new_response(body)
</span><span class="inferred0"><a name="line656"></a>656         m = new
</span><span class="inferred1"><a name="line657"></a>657         m.header.init_response(Status::OK)
</span><span class="inferred0"><a name="line658"></a>658         m.body = Body.new
</span><span class="inferred1"><a name="line659"></a>659         m.body.init_response(body)
</span><span class="inferred0"><a name="line660"></a>660         m.header.body_size = m.body.size || 0
</span><span class="inferred1"><a name="line661"></a>661         m
</span><span class="inferred0"><a name="line662"></a>662       end
</span><span class="inferred1"><a name="line663"></a>663 
</span><span class="marked0"><a name="line664"></a>664       @@mime_type_handler = nil
</span><span class="inferred1"><a name="line665"></a>665 
</span><span class="inferred0"><a name="line666"></a>666       # Sets MIME type handler.
</span><span class="inferred1"><a name="line667"></a>667       #
</span><span class="inferred0"><a name="line668"></a>668       # handler must respond to :call with a single argument :path and returns
</span><span class="inferred1"><a name="line669"></a>669       # a MIME type String e.g. 'text/html'.
</span><span class="inferred0"><a name="line670"></a>670       # When the handler returns nil or an empty String,
</span><span class="inferred1"><a name="line671"></a>671       # 'application/octet-stream' is used.
</span><span class="inferred0"><a name="line672"></a>672       #
</span><span class="inferred1"><a name="line673"></a>673       # When you set nil to the handler, internal_mime_type is used instead.
</span><span class="inferred0"><a name="line674"></a>674       # The handler is nil by default.
</span><span class="marked1"><a name="line675"></a>675       def mime_type_handler=(handler)
</span><span class="uncovered0"><a name="line676"></a>676         @@mime_type_handler = handler
</span><span class="uncovered1"><a name="line677"></a>677       end
</span><span class="inferred0"><a name="line678"></a>678 
</span><span class="inferred1"><a name="line679"></a>679       # Returns MIME type handler.
</span><span class="marked0"><a name="line680"></a>680       def mime_type_handler
</span><span class="uncovered1"><a name="line681"></a>681         @@mime_type_handler
</span><span class="uncovered0"><a name="line682"></a>682       end
</span><span class="inferred1"><a name="line683"></a>683 
</span><span class="inferred0"><a name="line684"></a>684       # For backward compatibility.
</span><span class="marked1"><a name="line685"></a>685       alias set_mime_type_func mime_type_handler=
</span><span class="marked0"><a name="line686"></a>686       alias get_mime_type_func mime_type_handler
</span><span class="inferred1"><a name="line687"></a>687 
</span><span class="marked0"><a name="line688"></a>688       def mime_type(path) # :nodoc:
</span><span class="uncovered1"><a name="line689"></a>689         if @@mime_type_handler
</span><span class="uncovered0"><a name="line690"></a>690           res = @@mime_type_handler.call(path)
</span><span class="uncovered1"><a name="line691"></a>691           if !res || res.to_s == ''
</span><span class="uncovered0"><a name="line692"></a>692             return 'application/octet-stream'
</span><span class="uncovered1"><a name="line693"></a>693           else
</span><span class="uncovered0"><a name="line694"></a>694             return res
</span><span class="uncovered1"><a name="line695"></a>695           end
</span><span class="uncovered0"><a name="line696"></a>696         else
</span><span class="uncovered1"><a name="line697"></a>697           internal_mime_type(path)
</span><span class="uncovered0"><a name="line698"></a>698         end
</span><span class="uncovered1"><a name="line699"></a>699       end
</span><span class="inferred0"><a name="line700"></a>700 
</span><span class="inferred1"><a name="line701"></a>701       # Default MIME type handler.
</span><span class="inferred0"><a name="line702"></a>702       # See mime_type_handler=.
</span><span class="marked1"><a name="line703"></a>703       def internal_mime_type(path)
</span><span class="uncovered0"><a name="line704"></a>704         case path
</span><span class="uncovered1"><a name="line705"></a>705         when /\.txt$/i
</span><span class="uncovered0"><a name="line706"></a>706           'text/plain'
</span><span class="uncovered1"><a name="line707"></a>707         when /\.(htm|html)$/i
</span><span class="uncovered0"><a name="line708"></a>708           'text/html'
</span><span class="uncovered1"><a name="line709"></a>709         when /\.doc$/i
</span><span class="uncovered0"><a name="line710"></a>710           'application/msword'
</span><span class="uncovered1"><a name="line711"></a>711         when /\.png$/i
</span><span class="uncovered0"><a name="line712"></a>712           'image/png'
</span><span class="uncovered1"><a name="line713"></a>713         when /\.gif$/i
</span><span class="uncovered0"><a name="line714"></a>714           'image/gif'
</span><span class="uncovered1"><a name="line715"></a>715         when /\.(jpg|jpeg)$/i
</span><span class="uncovered0"><a name="line716"></a>716           'image/jpeg'
</span><span class="uncovered1"><a name="line717"></a>717         else
</span><span class="uncovered0"><a name="line718"></a>718           'application/octet-stream'
</span><span class="uncovered1"><a name="line719"></a>719         end
</span><span class="uncovered0"><a name="line720"></a>720       end
</span><span class="inferred1"><a name="line721"></a>721 
</span><span class="inferred0"><a name="line722"></a>722       # Returns true if the given HTTP version allows keep alive connection.
</span><span class="inferred1"><a name="line723"></a>723       # version:: Float
</span><span class="marked0"><a name="line724"></a>724       def keep_alive_enabled?(version)
</span><span class="uncovered1"><a name="line725"></a>725         version &gt;= 1.1
</span><span class="uncovered0"><a name="line726"></a>726       end
</span><span class="inferred1"><a name="line727"></a>727 
</span><span class="inferred0"><a name="line728"></a>728       # Returns true if the given query (or body) has a multiple parameter.
</span><span class="marked1"><a name="line729"></a>729       def multiparam_query?(query)
</span><span class="uncovered0"><a name="line730"></a>730         query.is_a?(Array) or query.is_a?(Hash)
</span><span class="uncovered1"><a name="line731"></a>731       end
</span><span class="inferred0"><a name="line732"></a>732 
</span><span class="inferred1"><a name="line733"></a>733       # Returns true if the given object is a File.  In HTTPClient, a file is;
</span><span class="inferred0"><a name="line734"></a>734       # * must respond to :read for retrieving String chunks.
</span><span class="inferred1"><a name="line735"></a>735       # * must respond to :path and returns a path for Content-Disposition.
</span><span class="inferred0"><a name="line736"></a>736       # * must respond to :pos and :pos= to rewind for reading.
</span><span class="inferred1"><a name="line737"></a>737       #   Rewinding is only needed for following HTTP redirect.  Some IO impl
</span><span class="inferred0"><a name="line738"></a>738       #   defines :pos= but raises an Exception for pos= such as StringIO
</span><span class="inferred1"><a name="line739"></a>739       #   but there's no problem as far as using it for non-following methods
</span><span class="inferred0"><a name="line740"></a>740       #   (get/post/etc.)
</span><span class="marked1"><a name="line741"></a>741       def file?(obj)
</span><span class="uncovered0"><a name="line742"></a>742         obj.respond_to?(:read) and obj.respond_to?(:path) and
</span><span class="uncovered1"><a name="line743"></a>743           obj.respond_to?(:pos) and obj.respond_to?(:pos=)
</span><span class="uncovered0"><a name="line744"></a>744       end
</span><span class="inferred1"><a name="line745"></a>745 
</span><span class="marked0"><a name="line746"></a>746       def create_query_part_str(query) # :nodoc:
</span><span class="uncovered1"><a name="line747"></a>747         if multiparam_query?(query)
</span><span class="uncovered0"><a name="line748"></a>748           escape_query(query)
</span><span class="uncovered1"><a name="line749"></a>749         elsif query.respond_to?(:read)
</span><span class="uncovered0"><a name="line750"></a>750           query = query.read
</span><span class="uncovered1"><a name="line751"></a>751         else
</span><span class="uncovered0"><a name="line752"></a>752           query.to_s
</span><span class="uncovered1"><a name="line753"></a>753         end
</span><span class="uncovered0"><a name="line754"></a>754       end
</span><span class="inferred1"><a name="line755"></a>755 
</span><span class="marked0"><a name="line756"></a>756       def escape_query(query) # :nodoc:
</span><span class="uncovered1"><a name="line757"></a>757         query.collect { |attr, value|
</span><span class="uncovered0"><a name="line758"></a>758           if value.respond_to?(:read)
</span><span class="uncovered1"><a name="line759"></a>759             value = value.read
</span><span class="uncovered0"><a name="line760"></a>760           end
</span><span class="uncovered1"><a name="line761"></a>761           escape(attr.to_s) &lt;&lt; '=' &lt;&lt; escape(value.to_s)
</span><span class="uncovered0"><a name="line762"></a>762         }.join('&amp;')
</span><span class="uncovered1"><a name="line763"></a>763       end
</span><span class="inferred0"><a name="line764"></a>764 
</span><span class="inferred1"><a name="line765"></a>765       # from CGI.escape
</span><span class="marked0"><a name="line766"></a>766       def escape(str) # :nodoc:
</span><span class="uncovered1"><a name="line767"></a>767         str.gsub(/([^ a-zA-Z0-9_.-]+)/n) {
</span><span class="uncovered0"><a name="line768"></a>768           '%' + $1.unpack('H2' * $1.size).join('%').upcase
</span><span class="uncovered1"><a name="line769"></a>769         }.tr(' ', '+')
</span><span class="uncovered0"><a name="line770"></a>770       end
</span><span class="uncovered1"><a name="line771"></a>771     end
</span><span class="inferred0"><a name="line772"></a>772 
</span><span class="inferred1"><a name="line773"></a>773 
</span><span class="inferred0"><a name="line774"></a>774     # HTTP::Message::Headers:: message header.
</span><span class="marked1"><a name="line775"></a>775     attr_accessor :header
</span><span class="inferred0"><a name="line776"></a>776 
</span><span class="inferred1"><a name="line777"></a>777     # HTTP::Message::Body:: message body.
</span><span class="marked0"><a name="line778"></a>778     attr_reader :body
</span><span class="inferred1"><a name="line779"></a>779 
</span><span class="inferred0"><a name="line780"></a>780     # OpenSSL::X509::Certificate:: response only.  server certificate which is
</span><span class="inferred1"><a name="line781"></a>781     #                              used for retrieving the response.
</span><span class="marked0"><a name="line782"></a>782     attr_accessor :peer_cert
</span><span class="inferred1"><a name="line783"></a>783 
</span><span class="inferred0"><a name="line784"></a>784     # Creates a Message.  This method should be used internally.
</span><span class="inferred1"><a name="line785"></a>785     # Use Message.new_connect_request, Message.new_request or
</span><span class="inferred0"><a name="line786"></a>786     # Message.new_response instead.
</span><span class="marked1"><a name="line787"></a>787     def initialize # :nodoc:
</span><span class="uncovered0"><a name="line788"></a>788       @header = Headers.new
</span><span class="uncovered1"><a name="line789"></a>789       @body = @peer_cert = nil
</span><span class="uncovered0"><a name="line790"></a>790     end
</span><span class="inferred1"><a name="line791"></a>791 
</span><span class="inferred0"><a name="line792"></a>792     # Dumps message (header and body) to given dev.
</span><span class="inferred1"><a name="line793"></a>793     # dev needs to respond to &lt;&lt;.
</span><span class="marked0"><a name="line794"></a>794     def dump(dev = '')
</span><span class="uncovered1"><a name="line795"></a>795       str = header.dump + CRLF
</span><span class="uncovered0"><a name="line796"></a>796       if header.chunked
</span><span class="uncovered1"><a name="line797"></a>797         dev = body.dump_chunked(str, dev)
</span><span class="uncovered0"><a name="line798"></a>798       elsif body
</span><span class="uncovered1"><a name="line799"></a>799         dev = body.dump(str, dev)
</span><span class="uncovered0"><a name="line800"></a>800       else
</span><span class="uncovered1"><a name="line801"></a>801         dev &lt;&lt; str
</span><span class="uncovered0"><a name="line802"></a>802       end
</span><span class="uncovered1"><a name="line803"></a>803       dev
</span><span class="uncovered0"><a name="line804"></a>804     end
</span><span class="inferred1"><a name="line805"></a>805 
</span><span class="inferred0"><a name="line806"></a>806     # Sets a new body.  header.body_size is updated with new body.size.
</span><span class="marked1"><a name="line807"></a>807     def body=(body)
</span><span class="uncovered0"><a name="line808"></a>808       @body = body
</span><span class="uncovered1"><a name="line809"></a>809       @header.body_size = @body.size if @header
</span><span class="uncovered0"><a name="line810"></a>810     end
</span><span class="inferred1"><a name="line811"></a>811 
</span><span class="inferred0"><a name="line812"></a>812     # Returns HTTP version in a HTTP header.  Float.
</span><span class="marked1"><a name="line813"></a>813     def version
</span><span class="uncovered0"><a name="line814"></a>814       @header.http_version
</span><span class="uncovered1"><a name="line815"></a>815     end
</span><span class="inferred0"><a name="line816"></a>816 
</span><span class="inferred1"><a name="line817"></a>817     # Sets HTTP version in a HTTP header.  Float.
</span><span class="marked0"><a name="line818"></a>818     def version=(version)
</span><span class="uncovered1"><a name="line819"></a>819       @header.http_version = version
</span><span class="uncovered0"><a name="line820"></a>820     end
</span><span class="inferred1"><a name="line821"></a>821 
</span><span class="inferred0"><a name="line822"></a>822     # Returns HTTP status code in response.  Integer.
</span><span class="marked1"><a name="line823"></a>823     def status
</span><span class="uncovered0"><a name="line824"></a>824       @header.status_code
</span><span class="uncovered1"><a name="line825"></a>825     end
</span><span class="inferred0"><a name="line826"></a>826 
</span><span class="marked1"><a name="line827"></a>827     alias code status
</span><span class="marked0"><a name="line828"></a>828     alias status_code status
</span><span class="inferred1"><a name="line829"></a>829 
</span><span class="inferred0"><a name="line830"></a>830     # Sets HTTP status code of response.  Integer.
</span><span class="inferred1"><a name="line831"></a>831     # Reason phrase is updated, too.
</span><span class="marked0"><a name="line832"></a>832     def status=(status)
</span><span class="uncovered1"><a name="line833"></a>833       @header.status_code = status
</span><span class="uncovered0"><a name="line834"></a>834     end
</span><span class="inferred1"><a name="line835"></a>835 
</span><span class="inferred0"><a name="line836"></a>836     # Returns  HTTP status reason phrase in response.  String.
</span><span class="marked1"><a name="line837"></a>837     def reason
</span><span class="uncovered0"><a name="line838"></a>838       @header.reason_phrase
</span><span class="uncovered1"><a name="line839"></a>839     end
</span><span class="inferred0"><a name="line840"></a>840 
</span><span class="inferred1"><a name="line841"></a>841     # Sets  HTTP status reason phrase of response.  String.
</span><span class="marked0"><a name="line842"></a>842     def reason=(reason)
</span><span class="uncovered1"><a name="line843"></a>843       @header.reason_phrase = reason
</span><span class="uncovered0"><a name="line844"></a>844     end
</span><span class="inferred1"><a name="line845"></a>845 
</span><span class="inferred0"><a name="line846"></a>846     # Sets 'Content-Type' header value.  Overrides if already exists.
</span><span class="marked1"><a name="line847"></a>847     def contenttype
</span><span class="uncovered0"><a name="line848"></a>848       @header.contenttype
</span><span class="uncovered1"><a name="line849"></a>849     end
</span><span class="inferred0"><a name="line850"></a>850 
</span><span class="inferred1"><a name="line851"></a>851     # Returns 'Content-Type' header value.
</span><span class="marked0"><a name="line852"></a>852     def contenttype=(contenttype)
</span><span class="uncovered1"><a name="line853"></a>853       @header.contenttype = contenttype
</span><span class="uncovered0"><a name="line854"></a>854     end
</span><span class="inferred1"><a name="line855"></a>855 
</span><span class="inferred0"><a name="line856"></a>856     # Returns a content of message body.  A String or an IO.
</span><span class="marked1"><a name="line857"></a>857     def content
</span><span class="uncovered0"><a name="line858"></a>858       @body.content
</span><span class="uncovered1"><a name="line859"></a>859     end
</span><span class="uncovered0"><a name="line860"></a>860   end
</span><span class="uncovered1"><a name="line861"></a>861 
</span><span class="uncovered0"><a name="line862"></a>862 
</span><span class="uncovered1"><a name="line863"></a>863 end
</span></pre><hr/>
    <p>Generated using the <a href='http://eigenclass.org/hiki.rb?rcov'>rcov code coverage analysis tool for Ruby</a>
   version 0.8.2.1.</p>
<p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88'/>
        </a>
      <a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px'/>
        </a>
      </p>
    </body>
  </html>
